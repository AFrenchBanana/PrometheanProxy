# PrometheanProxy/src/Server/proxy/nginx.conf#L1-200
# Nginx reverse proxy configuration for:
# - Web server (frontend UI) -> proxied to service "web:8001"
# - Beacon server (C2 HTTP endpoints) -> proxied to service "server:2001"
#
# Assumptions:
# - This Nginx container joins the same Docker network (bridge) as the "web" and "server" services.
# - The service names "web" and "server" resolve via Docker DNS.
# - TLS termination is not configured here; you can add certs and enable HTTPS later if needed.
#
# Exposed proxy ports:
# - Web: listen 80 (HTTP)
# - Beacon: listen 8081 (HTTP)

# Basic, safe defaults
user  nginx;
worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;

    keepalive_timeout  65;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
    gzip_min_length 10240;

    # Proxy buffers and timeouts suitable for Django/WSGI and long-poll/WebSockets
    proxy_buffering off;
    proxy_read_timeout 300s;
    proxy_send_timeout 300s;
    proxy_connect_timeout 60s;

    # Set real IP headers (if running behind another proxy/load balancer, configure real_ip)
    map $http_x_forwarded_proto $proxy_x_forwarded_proto {
        default $http_x_forwarded_proto;
        ""      $scheme;
    }

    # Upstream backends (Docker service names)
    upstream promethean_web {
        server web:8001;
        keepalive 32;
    }

    upstream promethean_beacon {
        server server:2001;
        keepalive 32;
    }

    # ---------------------------
    # Web reverse proxy (HTTP:80)
    # ---------------------------
    server {
        listen 80;
        server_name _;

        # If you later add TLS, redirect HTTP->HTTPS here

        # Common headers for proxied requests
        set $proxy_host $host;

        location / {
            proxy_pass http://promethean_web;

            # Standard proxy headers
            proxy_set_header Host              $proxy_host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Host  $proxy_host;
            proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;

            # WebSocket support (Django Channels or Socket.IO if used)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # Buffers for larger responses (tables, lists)
            proxy_buffers 8 64k;
            proxy_busy_buffers_size 128k;
        }

        # Optional: health check endpoint
        location = /healthz {
            return 200 "ok\n";
        }
    }

    # ---------------------------------
    # Beacon reverse proxy (HTTP:8081)
    # ---------------------------------
    server {
        listen 8081;
        server_name _;

        # The beacon server is plain HTTP by design; we pass through as-is.
        # If you later want TLS termination, add 'listen 443 ssl;' and certificates.

        # Common headers
        set $proxy_host $host;

        # Proxy everything to the beacon endpoint. If your beacon uses specific paths,
        # you can narrow with location blocks. By default we forward all paths.
        location / {
            proxy_pass http://promethean_beacon;

            proxy_set_header Host              $proxy_host;
            proxy_set_header X-Real-IP         $remote_addr;
            proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Host  $proxy_host;
            proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;

            # Beacon traffic may use long-polling; extend timeouts
            proxy_read_timeout 600s;
            proxy_send_timeout 600s;
            proxy_connect_timeout 60s;

            # Keepalive/WebSocket safety (if the beacon uses them)
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }

        # Optional: narrow endpoint examples (uncomment if you want stricter routing)
        # location /beacon/ {
        #     proxy_pass http://promethean_beacon;
        # }

        location = /healthz {
            return 200 "ok\n";
        }
    }

    # helper: map for Connection header upgrades
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }
}
